from flask import Flask, abort, request, jsonify
import elasticsearch as ES

# CR: в стандартной библиотеке питона такого файла не существует => если это сторонняя библиотека, правильнее будет
# CR: отнести этот файл с библиотекам импортированным выше, иначе пробел между imports не оправдан
from validate import validate_args

app = Flask(__name__)


# CR: некорректое название функции, так как не передается симантический смысл объекта
# CR: нерациональное использован url='/', так как основной смысл задания не в проверке роботоспособности сервера
# CR: как вариант можно делать редирект на страницу с фильмами
@app.route('/')
def index():
    return 'worked'


# CR: между функциями должно быть расстояние в 2 пустых строки pep8
# CR: текущий фрагмент кода являетс функцией, поэтому правильно называть фунцию начиная с глагола,
# CR: например get_movie_list. Общее пожелание к функциям - делать их короче, иначе это может привести к макаронному
# CR: коду
# CR: Так же рекомендовано явно указывать что возвратит функция с помощию 'def f(...) -> your_return_type'
@app.route('/api/movies/')
def movie_list():
    validate = validate_args(request.args)  # CR: некорреткное название переменной, правильно использовать
    # CR: существительное

    # CR: некорректно хардкодить значения ошибок, лучше использовать константы тогда будет очевидно семантическое
    # CR: значение http кода, рекомендованно исползовать библиотеку python http
    # CR: а так же необходимо добавить логирование
    # CR: так же для получения по ключу лучше использовать validate.get('success') для избежания KeyError
    # CR: некорректно использовать 422 код ошибки, так как при ошибках необходимо возвращать, например 400 код ошибки
    if not validate['success']:
        return abort(422)

    #  CR: захардкожены значения, лучшей практикой будет выенсит словрь из функции и формировать его при помощи некой
    #  CR: другой функции, передавая в нее необходимые значения, так же некорректно использовать название default так
    #  CR: как
    #  CR: не понятен смысл словаря
    defaults = {
        'limit': 50,
        'page': 1,
        'sort': 'id',
        'sort_order': 'asc'
    }

    # CR: коментарий снизу не несет смысловой нагрузки для другого разработчика, от таких коментарием лучше избавляться
    # Тут уже валидно все
    for param in request.args.keys():
        defaults[param] = request.args.get(param)

    # Уходит в тело запроса. Если запрос не пустой - мультисерч, если пустой - выдает все фильмы
    # CR: Опять же правильнее всего вынести в отдельную функцию, что бы не заграмождать функцию дополнительной логикой
    body = {
        "query": {
            "multi_match": {
                "query": defaults['search'],
                "fields": ["title"]
            }
        }
    } if defaults.get('search', False) else {}  # CR: Можно не делать дефолтное значение, а оставить просто
    # CR: defaults.get(
    # CR: ...) так как если ключ не будет найдеен и вернется None, то if None = False и сработает сразу блок else.

    body['_source'] = dict()
    body['_source']['include'] = ['id', 'title', 'imdb_rating']

    params = {
        # CR: '_source': ['id', 'title', 'imdb_rating'],  правильнее будет удалить закоментированный код так как он не
        # CR: несет смысловой нагрузки, а лишь засоряет код
        'from': int(defaults['limit']) * (int(defaults['page']) - 1),  # рекомендовано исполозовать defaults.get а
        # CR: так же нет необходимости использовать функции int так как ключи являются изначально типа integer
        'size': defaults['limit'],
        'sort': [
            {
                defaults["sort"]: defaults["sort_order"]  # CR: не рациональное использовать одновременно одинарные и
                # CR: двойные кавычки, стоит остановиться на чем-то одном
            }
        ]
    }

    # CR: Правильнее всего вынести один открытие/закрытие клиента ES на уровне модуля вместо создания на каждый запрос.
    # CR: Ip и port нельзя хардкодить прямо внутри файла кода.
    es_client = ES.Elasticsearch([{'host': '192.168.11.128', 'port': 9200}], )
    search_res = es_client.search(
        body=body,
        index='movies',
        params=params,
        filter_path=['hits.hits._source']
    )
    es_client.close()

    return jsonify([doc['_source'] for doc in search_res['hits']['hits']])


@app.route('/api/movies/<string:movie_id>')
def get_movie(movie_id):  # CR: стоит указывать какой тип имеет передаваемый в функцию объект, в данно случае
    # CR: def get_movie(movie_id: int):
    # CR: Не стоит использовать хардкод такой информации (ip и port'а). Это стоит выносить как минмум в отдельный файл
    # CR: настроек проекта, лучше же всего выносить в некий отдельный файл конфига, а затем парсить из него данные в 
    # проект.
    es_client = ES.Elasticsearch([{'host': '192.168.11.128', 'port': 9200}], )

    # CR: print не имеет особого смысла, плюс ко всему некорреткно при неоткрытии сессии es игнорировать это событие,
    # CR: должен быть обработчик ошибки, так же желательно должно быть логирование.
    if not es_client.ping():
        print('oh(')

    search_result = es_client.get(index='movies', id=movie_id, ignore=404)

    es_client.close()

    # CR: Если search_result не будет иметь ключ found тогда программа упадет в ошибку, такое необходимо обрабатывать
    # CR: или
    # CR: как минмум использовать search_result.get(...), тогда хотя бы код просто не исполнится, но не упадет в ошибку.
    if search_result['found']:
        return jsonify(search_result['_source'])

    # CR: для поноценного понимания 404 кода стоит возвращать не только код, но и некоторую смысловую часть ошибки,
    # CR: например можно возвращать response body, кроме этого стоит логировать возникающие ошибки. Может быть 
    # CR: непонятным
    # CR: использование цифры 404, лучше использовать библиотеку 404 или как минмум выносить в константу с семантически
    # CR: понятным названием, например NOT_FOUND_ERROR
    return abort(404)


# CR: 1) между функциями должно быть расстояние в 2 пустых строки
# CR: 2) Нельзя хаодкодить порт и айпи адрес.
if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
